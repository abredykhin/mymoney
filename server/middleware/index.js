/**
 * @file Defines custom Express middleware functions.
 */

const Boom = require('@hapi/boom');
const sessionQueries = require('../db/queries/sessions');
const userQueries = require('../db/queries/users');
const logger = require('../utils/logger')('middleware');

/**
 * A higher-order function that wraps an async callback to properly trigger the
 * Express error-handling middleware on errors.
 *
 * @param {Function} fn an async callback.
 * @returns {Function} an Express callback that resolves the wrapped async fn.
 */
const asyncWrapper = fn => (req, res, next) => {
  return Promise.resolve(fn(req, res, next)).catch(error => {
    logger.error('Caught an error!');

    if (error.isBoom) {
      logger.error('The error is boom. Sending it to client directly.');
      // Return the Boom error directly with its appropriate status code
      return res.status(error.output.statusCode).json(error.output.payload);
    } else {
      // Still log the error for debugging
      logger.error(
        'The error is not boom. Will wrap in boom and send to client as 500 error code.'
      );
      logger.error(error);
      // Create a Boom error with a 500 status code and a generic message
      const boomError = Boom.internal('Internal Server Error');
      return res
        .status(boomError.output.statusCode)
        .json(boomError.output.payload);
    }
  });
};

/**
 * A catch-all error handler that sends a formatted JSON response.
 * Uses Boom to set the status code and provide consistent formatting.
 *
 * If using multiple error handlers, this should be the last one.
 *
 * @param {Object} err a javascript Error object.
 * @param {Object} req the Express request object.
 * @param {Object} res the Express response object.
 * @param {Function} next the Express next callback.
 */
/**
 * @file Fixed errorHandler function for middleware
 */

const errorHandler = (err, req, res, next) => {
  logger.error('Got an unhandled error!');
  let error = err;

  // handle errors from the Plaid api.
  if (error.name === 'PlaidError') {
    logger.error('The error came fom Plaid.');
    // Use the correct Boom factory function based on status code
    if (error.status_code === 400) {
      error = Boom.badRequest(error.error_message);
    } else if (error.status_code === 401) {
      error = Boom.unauthorized(error.error_message);
    } else if (error.status_code === 403) {
      error = Boom.forbidden(error.error_message);
    } else if (error.status_code === 404) {
      error = Boom.notFound(error.error_message);
    } else if (error.status_code === 409) {
      error = Boom.conflict(error.error_message);
    } else if (error.status_code >= 500) {
      error = Boom.badImplementation(error.error_message);
    } else {
      // Default to a generic error with the status code
      error = Boom.boomify(new Error(error.error_message), {
        statusCode: error.status_code,
      });
    }
  }

  // handle standard javascript errors.
  if (!error.isBoom) {
    logger.error('Error is standard JS error');
    error = Boom.boomify(error);
  }

  // these are generated by Boom, so they're guaranteed to exist.
  const { statusCode, payload } = error.output;
  res.status(statusCode).json(payload);
};

const verifyToken = async (req, res, next) => {
  logger.debug('Verifying token...');
  const authHeader = req.headers.authorization;

  if (typeof authHeader !== 'undefined') {
    logger.debug(`Auth header is present.`);
    const [header, token] = authHeader.split(' ');

    if (!(header && token)) {
      logger.error(`Unable to split into header/token pair!`);
      return next(Boom.unauthorized('Token not found!'));
    }

    logger.debug('Looking up user by token');
    const userId = await sessionQueries.lookupToken(token);
    if (!userId) {
      return next(Boom.unauthorized('Token not found!'));
    }

    logger.debug(`Found user ${userId.user_id}. Now looking up full user info`);

    const user = await userQueries.retrieveUserById(userId.user_id);
    if (!user) {
      logger.error('Weird, but full user info is not found.');
      return next(Boom.unauthorized('Token not found!'));
    }

    logger.debug('All good! Verification is complete.');
    req.token = token;
    req.user = user;
    req.userId = user.id;

    next();
  } else {
    logger.error('Auth header is missing.');
    return next(Boom.unauthorized('Token not found!'));
  }
};

module.exports = { asyncWrapper, errorHandler, verifyToken };
